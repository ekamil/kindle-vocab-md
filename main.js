/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cli.ts
var import_extra_typings = require("@commander-js/extra-typings");

// package.json
var name = "kindle-vocab-md";
var version = "0.1.0-alpha";
var description = "Export utility for Kindle Vocabulary";

// src/cli.ts
var program = new import_extra_typings.Command().description(description).version(version).name(name).option(
  "-d, --database <path>",
  "path to vocab.db SQLite database",
  "./vocab.db"
).option("-o, --output <path>", "directory or file for the results", "./out").addOption(
  new import_extra_typings.Option("-f, --format <format>", "output format").choices([
    "md-file" /* MarkdownFile */,
    "md-dir" /* MarkdownDir */,
    "csv" /* CSV */
  ]).default("md-dir" /* MarkdownDir */)
);

// src/render.ts
var import_nunjucks = __toESM(require("nunjucks"));

// src/templates/index.ts
var fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
function readTemplate(name2) {
  return fs.readFileSync(import_path.default.join(__dirname, `${name2}.njk`), {
    encoding: "utf8",
    flag: "r"
  });
}
var WordTemplate = readTemplate("word");

// src/render.ts
var vars = {
  word: "foo",
  usage: "Foo was barred for the bar"
};
var testRender = () => {
  const res = import_nunjucks.default.renderString(WordTemplate, vars);
  console.log(res);
};

// src/select.ts
var import_sqlite3 = require("sqlite3");
var db = new import_sqlite3.Database("vocab.db");
var testSelect = () => {
  db.get("SELECT * from words limit 1", (_, res) => console.log(res));
  db.get("SELECT * from lookups limit 1", (_, res) => console.log(res.usage));
};

// src/main.ts
program.parse();
var options = program.opts();
console.log(options);
testRender();
testSelect();
//# sourceMappingURL=main.js.map
